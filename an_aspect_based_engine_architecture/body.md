# An Aspect-Based Engine Architecture -Donald Revie-


## 10.1 Introduction
エンジンを構成するものの定義は、業界によって異なります。最も基本的には、この用語は、複数のプロジェクトで共通の機能を提供するコードベースを表します。目的は、この機能を開発するために必要なリソースのコストを共有することです。より高度なエンジンは、ゲーム開発プロセスに大きな影響を与えるプラットフォームとツールを提供します。エンジンのアーキテクチャは、そのエンジンがどれだけ柔軟性、機能性、信頼性、拡張性があり、複数のプロジェクトにまたがって使用することができるかを決定します。ゲームはオブジェクトで構成されるシミュレーションが中心になる傾向があるため、ほとんどのエンジンはオブジェクトレベルでこれらの原則を適用し、様々なクラスのオブジェクトを作成し、多くの場合は継承階層で、複雑な機能を持つようにしています。アグレゲーションを使用して、エンジンはアスペクトと呼ばれるモジュールで構成され、それぞれがレンダリング、オーディオ、物理シミュレーションなどの必要な機能の厳密なサブセットを提供します。これらのアスペクトは共通のインターフェースを共有しており、エンジンのコアと通信し、現在のゲーム状態を記述する共有データにアクセスすることができます。理論的には、各アスペクトは非常に特殊なタスクを持つ個別のエンジンであり、提供する機能に最適な狭い視点でコア内の共有データを解釈します。

## 10.2 Rationale

エンジンの設計・開発は、プログラミングだけの問題ではなく経営者の一人です。スタッフと このようなエンジンは、計画と実行に何ヶ月もの時間をかけて専門のチームで開発されることはほとんどありません。アスペクトベースのエンジンアーキテクチャは、すべてのアスペクトが記述されなければならないシンプルなインターフェイスとルールのセットを作成することにより、管理の負担を軽減します。このように、このアーキテクチャは、エンジンのすべての要素を設計・管理するための専用の構造を確立する余裕がないが、自分たちの技術を開発することで得られるメリットを利用したいという小規模なチームや分散型のチームに適しています。また、モジュール性が高いため、開発の方向性の変更や、要件の異なる複数のプロジェクトへの対応も可能です。


## 10.3 Engine Core
コアはエンジンの最も重要な要素であり、すべてのアスペクトはいつでも配置や変更が可能ですが、それぞれのアスペクトはコアが提供するインターフェースや機能に大きく依存しているため、開発期間中もコアが安定した状態を維持することが極めて重要です。エンジンコアの機能は、アスペクトが作用するゲームやシミュレーションの構造と状態を保存することです。


### 10.3.1 Scene Graph
エンジン設計の核となるコンポーネントの 1 つは、ゲームのシミュレーション環境の表現であり、ゲーム内のすべてのものを作成するために相互に作用するオブジェクトや概念の実際の論理的表現です。この表現は、シーングラフのようなものとして保存され、各ノードがシミュレーション内の注目ポイントを表すツリー構造になっています。しかし、シーングラフという言葉が示すように、その機能は厳密には定義されていません。このツリーは必ずしも一つの物理的な空間を表しているわけではありません。一つの枝（サブグラフ）には 3D シーンの情報が格納され、別の枝には 2D GUI と純粋に抽象的なデータが格納されているかもしれません（図 10.2）。

### 10.3.2 Scene Nodes
シーングラフはそのサブグラフに特定の意味を課さないため、シミュレーションの構造は純粋にデータを介して定義されます。このような柔軟性を高めるために、シーングラフのノードは、通常のような継承階層を使用して定義されておらず、代わりに実行時にアグリゲーションを使用して構成されています。

シーン・グラフ内の各ノードは、名前とタイプによって識別されるデータ・アトリビュートのリストを格納します（図10.3）。ノードの意味とそのアトリビュートの構成は、エンジン設計によって制限されたり定義されたりするものではないので、必要に応じて様々な意味を表現することができます。ノードは、3Dシーンのライトやカメラなどの物理的なオブジェクトを表すことができ、同様に、キャラクターのアニメーションリグのボーンやマウスカーソルを表すことができます。また、ゲームのルールの中では、勝利条件のような抽象的な概念を表すこともあります。各ノードの意味は、グラフ内での相対的な位置、属性、そしてエンジンの残りの部分がどのように解釈されるかによって決まります。

### 10.3.3 Data Access
アグリゲーションを使用してノードを実装すると、ノード内に含まれるデータへの直接のアクセス手段を提供するインターフェイスがないことになります。その後、ノードは正しいタイプにテンプレート化されたアクセス・ポインタを返し、参照カウントをインクリメントします（図 10.4）。

マルチスレッド環境では、これらのポインタを介してコア要素の残りの部分に安全にアクセスするには、呼び出し側のスレッドが相互除外（ミューテックス）を取得する必要があります。このような状況では、関連するデータを複製し、定義されたポイントでコア・シーン・グラフと同期させることができるオブジェクトの内部表現に基づいて操作する方が効率的であることが多いです。

### 10.3.4 Subgraph State
シーン・グラフ内のノードは、そのノードでルートされたサブグラフ内のすべての子ノードに影響を与えるいくつかの状態のうちの1つになることができます(図10.5)。
+ アクティブ。ノードがアクティブな場合、すべての関心のある側面がそれを処理し、それに関連付けられたデータや内部リソースを更新することができることを意味します。
+ 非アクティブ。サブグラフはいつでも非アクティブにすることができます。非アクティブなサブグラフは、いつでも無効化することができます。サブグラフは、更新が始まる前にアスペクトが関連するリソースを初期化できるように、非アクティブな状態でシーンに追加されます。
+ 削除を保留中。サブグラフ内のすべてのノードは非アクティブで、まもなく削除されます。

すべてのノードアトリビュートと同様に、サブグラフの状態の正確な定義は、エンジンのユーザーによって定義することができます。しかし、そのような状態の全体的な影響と、様々なアスペクトがそれらをどのように解釈するかのために、追加の注意が必要です。

### 10.3.5 Event Queue
シーングラフとその構成ノードは、シミュレーションの現在の構造と状態を表しています。しかし、このシミュレーションは静的なままではありません。シミュレーションのロジックが実行されると、シーンの構造やノードの内容が変化することで特徴づけられます。

エンジンの側面は、シミュレーション状態の変化を認識し、それに反応しなければなりません。これは、シーンの要素が変化していないか継続的に検査することで実行できますが、それは法外に遅いでしょう。より効率的な解決策は、各アスペクトが更新中にレビューできるような変更を記述したイベントのキューを維持し、その機能に関連性のないイベントを無視することです。各イベントは、イベントの性質を記述する識別子を持ち、特定のノード内のノードまたはデータへの2つのポインタを提供することができます。これは、ノードの状態の変化、その中に根ざしたサブグラフの変化、ノード内の特定の属性の変化、または2つのノード間の相互作用のいずれかを示す、シミュレーション内の最も重要なイベントを記述するのに十分です。このように、サウンドとパーティクルエフェクトをもたらす2つのノード間の衝突は、それらを記述するイベントではなく、これらの要素を含む新しいサブグラフを生成することができます。


## 10.4 Aspects
エンジンコアは、シミュレーションの現在の状態と最近発生した変更を格納します。エンジンコアはシミュレーションの内容や、シミュレーションがどのように動作するかには関心がありません。その代わり、エンジンによって実行されるすべての操作は、アスペクトで行われます。アスペクトとは、エンジン機能の限定されたサブセットを提供するために存在するエンジンモジュールです。これには、レンダリング、アニメーション、物理学、オーディオ、ゲームのイベントロジックなどが含まれます。このように、アスペクトは、物理学などのタスクのために個々の API の機能をラップしたり、API の内部シミュレーションをエンジン コア内の対応するオブジェクトと同期させたりするために使用されることが多いです。それぞれのアスペクトの範囲は完全に任意であり、単一のアスペクトを使用して、既存のサードパーティのエンジン、フレームワーク、または関連するAPIのグループが提供するすべての機能をカプセル化することができます。同様に、単一のAPIは、その機能を複数のアスペクト間で細分化することができます。このアーキテクチャの制限の1つは、アスペクトは厳密な非依存性ルールを守るべきであるということです。したがって、2つの側面が特定のクラスを持つベースライブラリを共有している場合、このデータは、他のタイプのデータのようにエンティティに埋め込むことができます。それは興味のある側面にのみ関連するので、エンジンの他の部分からは不透明なままです。

アスペクトは、このような共有を最小限に抑えるように設計されるべきです。現在のグラフィックデバイス/コンテキストやウィンドウハンドルのようなスタティックリソースは、アスペクト間で共有すべきではありませんが、共有が避けられない場合は、アクセスを制御するためのミューテックスを提供すべきです。あるAPIを使用したオーディオアスペクトは、別のAPIを使用したアスペクトと相互に交換可能になります。エンジンは、単一のインターフェースを介してすべてのアスペクトを管理し、エンジンのユーザが指定した順序でアスペクトを初期化、更新、シャットダウンします。

### 10.4.1 Scene Interpretation
各アスペクトは、それが興味を持つノードへの参照の内部構造を維持する必要があります。関心は、特定のパターンを探してノードの属性を照会することによって決定されます。たとえば、剛体に一致する識別子を持つノードは物理学のアスペクトの関心事であり、一方、年齢測定とマテリアルのインスタンスを参照するノードはレンダリングのアスペクトの関心事であるとします。この構造の特徴とノードを参照する方法はアスペクトに合わせて調整することができ、提供する機能に対して最も効率的なソリューションを実現できます。それ以降は、ノードやシーングラフの構造の変更に関するイベントを受信し、それ自身の内部構造を同期させることができます。



### 10.4.2 Node Interfaces
新しいサブグラフが提示されると、アスペクトはその中のノードを検査し、クエリを実行します。 ノードが概念を表していることを示すデータのパターンを探しています。 のように、アスペクトが認識していることを示しています。この属性のパターンは、次のように考えることができます。 インタフェースは、ノードがその属性のサブセットを介してエクスポートするものです (図10.8)。 ほとんどの場合、これらのインターフェイスはアスペクトによって定義されます。 機能的な領域内のオブジェクトに直交します。オーディオアスペクトは、以下のように解釈します。 ノードを潜在的なサウンドエミッタ、レシーバ、または環境修飾剤として使用することができます。一方で アニメーションの側面では、骨や皮を表すノードに興味があるでしょう。 メッシュセグメントを使用しています。



場合によっては、アスペクトにロードされたデータを介してインターフェースが定義されることもあります。この方法では、エンジンは任意のアトリビュートへのアクセスを要求することができますが、通常は、ノードが別の定義済みインターフェースを使用して目的のオブジェクトを表していることを確認した後に、任意のアトリビュートへのアクセスを要求します。これにより、エンジンはノードのアトリビュートをスクリプトやシェーダの入力に自動的にマッピングすることができ、ノードやターゲットの内容を理解する必要はありません。APIをラップするアスペクトの場合、これらのオブジェクトはすでに提供されている可能性が高く、目的の機能を使用するために実際に必要とされています。これにより、アスペクトは並行して操作を実行することが可能になります。必要なのは、エンジンのコアをセットポイントでロックし、内部データを中央のシミュレーションと同期させることだけです。


## 10.5 Common Aspects
### 10.5.1 Render Aspect
GPU Pro 3 [Revie 12]の「データ駆動型レンダラの設計」の章では、レンダーアスペクトの重要な要素を詳細に説明しています。この設計では、カメラやライトなどの具体的なエンティティから、レンダリングの順序を制御するために使用されるフレームグラフの抽象的な要素まで、さまざまな概念を持つオブジェクトを定義する際のコアシーン表現の柔軟性について説明しています。また、シェーダのための任意の入力を取得するためにオブジェクトを照会するプロセスについても説明しています。


### 10.5.2 Logic Aspect
ロジックの側面では、ゲーム固有の機能を追加する必要があります。これは、シーングラフ内のオブジェクトを、プレイヤー、敵、武器、パワーアップなど、ゲーム内のエンティティとして解釈する側面です。これは、提供されたゲームのルールを使用してシーンを更新します。ロジックの側面が実装されている方法は大きく変化することができ、プロジェクトのニーズとチームのメイクアップに応じたものでなければなりません。プログラム中心のチームでは、エンジンコアへのインターフェイスを独自のエンティティクラスや構造体の後ろに隠して、コードを通してロジックの多くを処理したいと思うかもしれません。また、ロジックの側面は完全にデータ駆動型にすることもでき、個々のノードに接続されたスクリプトファイルを実行し、接続されたノードの内容をスクリプト言語内のパラメータまたはオブジェクトとして公開します。


### 10.5.3 Data Instrumentation Aspect
シンプルなGUIでコアの構成要素を公開するだけのアスペクトを実装することで、エンジンの利用者はエンジンの内部状態を直接観察したり、個々のノード属性の値を編集したりすることができるようになります。このようなアスペクトの開発レベルに応じて、属性値をフォーマットされた文字列として表示するシンプルなデバッグツールから、シーングラフの構造を操作できるゲーム内エディタ、ノード属性を編集するための複雑なウィジェットのレンダリングまで、機能は様々です。

### 10.5.4 File Aspect
この機能がエンジンコアにないことで注目すべきは、ファイルからエンジンにデータをロードする機能です。シーンデータのコアへのロードは、ファイルアスペクト（file aspect）によって制御されます。一旦見つかると、これらの名前はファクトリーシステムに提出されます。

+ ファクトリー。このファクトリーシステム自体はモジュラー構造に従っています。各ファイル・タイプは、ファイルを処理するファクトリー・モジュールに関連付けられ、その内容からサブグラフを構築します。シーンに挿入されると、新しいサブグラフは、ファイルのアスペクトを含むすべてのアスペクトによって解析され、サブグラフ内に含まれるすべてのファイル参照も処理されることを保証します。ファイルが単一のアスペクトに関連するリソースのみを含む場合、ファクトリーはアスペクトと直接通信したり、アスペクト自体の一部であったりすることができ、シーングラフにこのデータを挿入する必要性を回避することができます。

+ シーン・コンディショナー。シーンが様々なファイルタイプから構築され、ノードを再帰的に参照して構築される場合、この方法では、多くの冗長なノードや他の様々な非効率性を持つ構造になります。これに対抗するために、シーングラフのセクションを反復処理し、その構造を分析し、最適化するために、モジュールのさらなるシステムが使用されます。これらの条件付けモジュールは、アスペクトによって必要とされるエンティティにさらなる属性を追加するためにも使用され、アスペクトのための再処理段階として機能します。そして、一度シーングラフに挿入されたサブグラフは、グラフ内の位置のコンテキストに基づいて更なる処理を行うために、挿入後のコンディショナーによって処理されます。これらのコンディショナによって実行されるタスクは、エンジン、アスペクトのデザイン、ロードされるファイルのタイプに固有のものです。挿入前のコンディショナは、アセットのオーサリング時に必要とされるかもしれないが、特定のゲームでは必要とされないシーンデータを最適化するためによく使用されます。コンディショニングの段階でこれを行うことで、ファクトリーの複雑さが軽減され、より細かい制御が可能になります。これらには、以下のようなタスクが含まれます。

  + アセットパイプラインの前に API 固有のファイルにエクスポートされたが、ソースファイルに存在するコリジョンジオメトリを削除しました。
  + シーン内に存在するカメラやその他の UI エレメントを表すエディタ固有のノードを削除します。

一方、ポストインサーション・コンディショナーは、ファイルのコンテンツが参照されるコンテキストの知識を必要とするタスクを実行します。このようなタスクには次のようなものがあります。
  + 各ノードを参照するためのユニークなIDを生成する
  + このように、シーン内のサブグラフの直接の親に対してノードが配置され、相対的に方向付けされるように、参照元のサブグラフに変換を伝搬します。
  + 冗長ノードの長い列を折りたたむことで、トランスフォームを超えたデータを含まず、単一の子ノードのみを含む。これらは、しばしばdereferencing処理中に作成され、シーンの深さを人為的に増加させます。
+ オフライン処理。このアーキテクチャの柔軟性により、様々なエンジン構成だけでなく、同じデータセットで動作するツールの構築にも使用できます。このようなツールは、オフラインでシーンデータを処理したり分析したりするために使用することができ、ゲーム自体に関与するものとは全く異なるアスペクトやコンディショナーのセットを使用しています。


## 10.6 Implementation
このエンジン設計の重要な原則の1つは、シーンノードの構築です。 エンジンのコード内にある明示的なクラスではなく、データの集約を通じたものです。 アスペクトとコアシーン間の相互作用の多くは この原則の実施によって それゆえに、より詳細な の議論を参照してください。 ノードは、本質的には各属性の記述を関連付けるコンテナです。 は、名前と型の識別子を持ち、関連するデータへのポインタを持ちます。標準の テンプレート ライブラリ (STL) は、さまざまなプロパティを持つさまざまなコンテナを提供します。 と共有インターフェイス (リスト10.1を参照) の選択が比較的簡単になります。 を使用して、任意の状況に合わせたものを作成することができます [SGI 11]。この例では、連想コンテナ のようなマップやセット（属性の重複を許可したい場合は multimap/multiset）を作成します。 名前) は、コンテンツの検索が簡単なので、当然の選択でしょう。 が可能であり、要素を連続したメモリに格納する必要がありません。 コンテンツの挿入/削除時に過度の断片化が発生する。

```
std :: map < std :: pair < attribute name , attribute type > , attribute data >
```

実際には、すべての検索、挿入、およびデータの削除は、理想的にはオブジェクトの初期化とシャットダウンに再制限されるべきであり、コンテナの選択はそれほど重要ではありません。カスタム・アロケータは、コンテナからのメモリ再割り当ての影響をさらに軽減するために書くことができますが、その実装はこの章の範囲を超えています。しかし、コンテナは単一のタイプのオブジェクトしか保持できません。したがって、属性データの不均一なセットへの一様なポインタのセットを格納することによって、間接的な層を導入しなければなりません。データはヒープ上に構築され、ポインタはvoidにキャストされて返されます。これは、データに関するあらゆるタイプ情報を破棄し、元のタイプにキャストすることができずにデストラクタを呼び出す可能性があるという注目すべき欠点を持っています。これにより、インターフェイスクラスを介して型に関する情報にアクセスできるようになるだけでなく、属性データをクリーンアップするための適切な仮想デストラクタを提供します。一般的にランタイム型情報(RTTI)の一部として提供されるコンパイル時の機能を使用することで、保存されているデータの型を表す単純な型情報オブジェクトを取得することができ、他の型と比較して識別することができます。(リスト10.2を参照してください。) このような実装は、属性オブジェクトがそれらのデータへの正しくタイプされたポインタを格納するだけでなく、属性の識別名を格納し、型情報オブジェクトへのアクセスを提供することを可能にします。このように、検索時に属性を識別するために別のキーが必要とされず、ノードの内容は、属性の名前とタイプのためにインターフェイスポインタを問い合わせるカスタムソートアルゴリズムで構築されたセットを使って格納できます。

## 10.7 Aspect Interactions
アスペクトは意図的に互いに独立しており、エンジンのコアは、一般的なインターフェイスを介してそれらすべてと相互に作用する。セッションの間、エンジンのコアは初期化され、各アスペクトは順番に初期化されてからコアに登録され、イベントを受信し、シーン表現へのアクセスが提供されます。

```
class iAttribute
{
public :
  virtual ~iAttribute () = 0;
  virtual type_info GetTypeID () const = 0;
  virtual const std :: string &  GetName () const = 0;
};

template < typename _tAttribute >
class cAttribute : public iAttribute
{
public :
  cAttribute (): m_name () , m_pData ( NULL ) {}
  ~ cAttribute (){ if ( m_pData ) delete m_pData ; }
  type_info GetTypeID () const { return typeid ( _tAttribute ); }
  const std :: string & GetName () const { return m_name ; }
  _tAttribute * GetPointer () { return m_pData ; } 
private :
  m_name ;
  m_pData ;
};
```

これが発生すると、エンジンは1つ以上のスレッドを起動し、これらからアスペクトが必要とする任意のupdateループを実行することができます。エンジンの正しい機能は更新の順序に依存している可能性があり、通常、最適な順序と頻度があるでしょうどの側面が更新されるべきである。

### 10.7.1 Aspect Update
各アスペクトは自律的であり、実質的にはエンジンの機能性の垂直スライスであるため、各アスペクトは、そのサブセットの機能性に関して、コアシーンとそれ自身の内部リソースの両方を管理するために必要なすべての操作を実行する独自の更新ループを持っています（図10.9）。また、ロックを解除する前に、自分の内部オブジェクトの値を対応するシーンノードの値と同期させる必要があります。この時点では、アスペクトはエンジンの内部ロジックを実行しながら、並行して更新している可能性があります。内部状態が完全に更新されると、アスペクトはエンジンのコアにロックを再取得し、関連するデータとコアエンティティを同期させ、ロックを再び解放する前に新しいイベントを生成します。次の更新までの時間を待たなければなりません。
ステップを実行することができます。


### 10.7.2 Example: Entity Changing Color Upon Taking Damage

この簡単な例では、弾丸がゲーム内のキャラクタに当たってターゲットのマテリアル値が変化したときに、アスペクト駆動エンジンで発生する可能性のある一連の操作について説明します。
  + 1.物理アスペクトの更新中に、弾丸オブジェクトがキャラクタの衝突体と交差します。これは physicsAPI の内部イベントを生成します。更新終了時にコアと同期すると、物理アスペクトは弾丸とキャラクターを参照した衝突イベントをイベントキューにプッシュします。
  + 2.ロジックアスペクトは次に更新すると、キューから衝突イベントを取得します。イベントタイプ "Collision "を認識し、両方のノードを観測しています。弾丸と文字の両方の衝突ハンドラスクリプト関数を呼び出します。弾丸のコリジョンハンドラは、弾丸を表すサブグラフをシーンから削除するように要求します。キャラクタのサブグラフは、キャラクタの内部状態を「ダメージ」に変更し、キャラクタのヘルス属性から弾丸のダメージ属性を減算し、キャラクタのカラー属性を白から赤に変更します。 
  + 3.ロジック アスペクトがコアに対するロックを解除すると、レンダーアスペクトは更新を開始できます。レンダーアスペクトは、弾丸サブグラフ上の保留中の削除状態の変更に気づき、弾丸を表現するために使用している内部エンティティをクリーンアップします。次に、現在表示されているすべてのエンティティのシェーダ入力を、それぞれのノードのアトリビュートと同期させます。そうすると、キャラクタのアトリビュートから新しい色の値が引き出され、関連するバッチがレンダリングされたときに、キャラクタが赤く染まるようになります。

## 10.8 Praetorian: The Brief History of Aspects
コホートスタジオ独自のエンジンであるPraetorianは、前述のアスペクトベースのアーキテクチャを使用して開発されました。このエンジンの目的は、幅広いジャンルのゲームのプロトタイプを迅速に開発し、最も有望なプロジェクトを迅速に製品化することでした。アジャイルをテーマにした別のアプローチとしては、エンジンの機能性をプロジェクト内で直接開発し、プロジェクトの開発に合わせてコードをリファクタリングして、共通の機能を共有できるモジュールに落とし込むという方法があったかもしれません。しかし、そのようなアプローチでは、複数のプロジェクトを完成させる必要があり、幅広いゲームの基盤として使用できるエンジンを作るのに時間がかかるかもしれません。アスペクトという用語は、もともとOpenSGのマルチスレッドによる単一のシーングラフへのアクセスに関する研究で出てきたもので、各スレッドやリモートクライアントがシーングラフの内容について特定の視点を維持することを示していました。これは、単純なマルチスレッドアクセスから、必要とされるタスクに応じて異なる視点を持つという考え方へと分岐し、本章で説明したようなaspectsの概念へと発展しました。これは、それらの間に依存関係を作ることなく、すべてのアスペクトのニーズを満たすことができるエンティティのヒエラルキーを開発するという問題をすっきりと回避することになるだろう。

イベント管理はコアの中心的な部分ではなかったが、後に実装された。イベントはトランスフォームアスペクト内でノードの位置の更新を子に正しく伝えるために使用され、その後、物理オブジェクト間の衝突イベントに関連して使用され、最後にシーングラフ内に実装され、シーングラフの構造に対する非同期操作、挿入と削除の処理を容易にするために使用された。後になって考えれば、効率の悪い設計を進めることになっても、最初から偶数処理を実装しておいた方が効率的だったかもしれません。これにより、モデルエディットからアセットをエクスポートすることができます。

## 10.9 Analysis
すべての設計と同様に、エンジンを構築するための利点と制限があります。アスペクトベースのアーキテクチャの特徴は、主にモジュール性とデータの柔軟性を通じて開発プロセスに恩恵をもたらしますが、硬直した構造と間接性は効率性に限界をもたらします。アスペクトに基づいてエンジンを構築することの利点は、以下のようなものがあります。
  + データ駆動型の開発哲学を促進することは、資産作成者および設計者を従事させるのに役立つ。
  + 高度にモジュール化されたドロップイン/ドロップアウトのアーキテクチャにより、エンジンの変更を迅速に行うことができます。
  + モジュール化されているため、エラーの追跡とデバッグが迅速に行えます。
  + カプセル化により、サードパーティAPIの統合が加速されます。
  + シェーダとスクリプト入力を直接接続することで、新しいグラフィック技術やプロトタイプゲーム機能の開発をより簡単かつ迅速に行うことができます。
  + 知識と機能の管理を分散化することで、異なる側面のプログラマーの自律性が向上します。
+ 制限。次は制限のいくつかである。
  + アスペクト内で重複または冗長なデータが作成され、コア内にデータを格納するために使用される集約構造は、メモリ効率を著しく低下させる可能性があります。
  + アスペクトの非同期性は、原因と結果がコードの中で直接隣接していることはほとんどないため、プログラマーが作業するのは難しいかもしれません。
  + 実行の複数スレッド間でアスペクト間の完全な自律性を維持しようとすると、更新順序を調整するための追加のメカニズムが必要になります。

## 10.10 Conclusion
エンジンを書く方法は、プログラマーの数だけあります。アスペクトベースのアーキテクチャは、それ自体がエンジンの設計であるのと同様に、開発者の個性やプロジェクトのニーズに譲歩しています。同時に、アスペクトのカプセル化や共有データへのアクセスに関する厳格なルールは、どうしても最適化を制限してしまいますが、機能設計の構造化や情報提供に役立ち、必要なものをより早く実装することができます。エンジンの能力が伸びる場面は必ずありますが、この設計の範囲内では乗り越えられないと証明されたものはありません。


## 10.11 Acknowledgments
コホート・スタジオで働いてくれた全ての人に感謝します。特にPraetorianとそのデザインに影響を与えてくれた人たちに感謝します。また、私が彼に物事を言ったときに多くの信仰を示してくれたゴードン・ベルに感謝します。また、エンジンの設計を様々な方法で押し進めてくれたShaun Simpsonにも感謝します。

## Bibliography
[Cafrelli 01] C. Cafrelli. “A Property Class for Generic C++ Member Access.” In
Game Programming Gems 2, edited by Mark DeLoura, pp. 46–50. Hingham,
MA: Charles River Media, 2001.

[Revie 12] D. Revie, “Designing a Data-Driven Renderer.” In GPU Pro 3, edited
by Wolfgang Engel, pp. 291–319. Boca Raton, FL: CRC Press, 2012.

[SGI 11] Silicon Graphics International. Standard Template Library. http://www.
sgi.com/tech/stl/, 2011.

[Voss et al. 02] G. Voss, J. Behr, D. Reiners, and M. Roth. “A Multi-Thread Safe
Foundation for Scene Graphs and Its Extension to Clusters.” In Proceedings
of the Fourth Eurographics Workshop on Parallel Graphics and Visualiza-
tion, pp. 33–37. Aire-la-Ville, Switzerland: Eurographics Association, 2002.
